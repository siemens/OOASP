from argparse import ArgumentParser
import time

from clingo import Control, Number, Function
from clingo import parse_term
from clingo.symbol import Symbol
import ooasp.settings as settings
from ooasp.utils import red, green, title, subtitle, pretty_dict


from clingraph.orm import Factbase
from clingraph.graphviz import compute_graphs, render
from clingraph.clingo_utils import ClingraphContext


CLASSES = [
    "object",
    "element",
    "rack",
    "module",
    "frame",
    "rackSingle",
    "rackDouble",
    "elementA",
    "elementB",
    "elementC",
    "elementD",
    "moduleI",
    "moduleII",
    "moduleIII",
    "moduleIV",
    "moduleV",
]

SMART_FUNCTIONS = {
    "object_needed": {"type": "cautious", "arity": 6},
    "global_ub": {"type": "cautious", "arity": 3},
    "global_lb": {"type": "cautious", "arity": 3},
    "association_needed": {"type": "brave", "arity": 4},
}


def get_parser() -> ArgumentParser:
    """
    Return the parser for command line options.
    """
    parser = ArgumentParser(
        prog="ooasp",
    )
    # ------------------------General------------------------
    parser.add_argument("--verbose", action="store_true", help="Verbose output")
    parser.add_argument(
        "--view",
        action="store_true",
        help="Saves the solution as a PNG generated by clingraph",
    )
    # ------------------------Smart generation options ------------------------
    parser.add_argument(
        "--smart_generation",
        type=str,
        help=f"""Specifies what functions for smart generation to use.
                    Possible options: {list(SMART_FUNCTIONS.keys())}.
                    Input has to be comma-separated list.
                    Functions are executed in the order specified.""",
    )
    # ------------------------Initial objects------------------------
    for c in CLASSES:
        parser.add_argument(f"--{c}", type=int, default=0, help=f"Number of {c}s")
    return parser


class OOASPRacksSolver:

    def __init__(self, options, initial_objects=None, smart_generation_functions=None):
        self.options = options
        self.initial_objects = initial_objects if initial_objects is not None else []
        self.smart_generation_functions = (
            smart_generation_functions if smart_generation_functions is not None else []
        )

        self.ctl = Control(
            [
                "1",
                "--warn=none",
                "-c config_name=c1",
                "-c kb_name=k1",
                "-t3",
                "--project=show",
            ]
        )
        self.ctl.load("examples/racks/kb.lp")
        self.ctl.load("ooasp/encodings/ooasp_simple.lp")

        self.ctl.ground([("base", [])])
        self.ctl.solve()
        self.next_id = 1
        self.associations = []
        self.model = None
        self.cautious = None
        self.brave = None
        self.times = {
            "runtime": 0,
            "initialization": 0,
            "smart_generation": {
                "time": 0,
                "cautious": 0,
                "brave": 0,
                "functions": {n: 0 for n in smart_generation_functions},
            },
            "solve": 0,
            "ground": 0,
        }
        self.objects = {c: 0 for c in CLASSES}

        def log(*args):
            if self.options.verbose:
                print(*args)

        self.log = log

    @property
    def stats(self):
        times = {
            "runtime": round(self.times["runtime"], 3),
            "initialization": round(self.times["initialization"], 3),
            "smart_generation": {
                "time": round(self.times["smart_generation"]["time"], 3),
                "cautious": round(self.times["smart_generation"]["cautious"], 3),
                "brave": round(self.times["smart_generation"]["brave"], 3),
                "functions": {
                    k: round(v, 3)
                    for k, v in self.times["smart_generation"]["functions"].items()
                },
            },
            "solve": round(self.times["solve"], 3),
            "ground": round(self.times["ground"], 3),
        }
        considered_coseq = {"cautious": False, "brave": False}
        for f in self.smart_generation_functions:
            conseq_type = SMART_FUNCTIONS[f]["type"]
            if not considered_coseq[conseq_type]:
                considered_coseq[conseq_type] = True
                times["smart_generation"]["functions"][f] = round(
                    (
                        times["smart_generation"]["functions"][f]
                        - times["smart_generation"][conseq_type]
                    ),
                    3,
                )
        results = {
            "#objects": self.next_id - 1,
            "#objects_per_type": {k: v for k, v in self.objects.items() if v > 0},
            "#associations": len(self.associations),
            "times": times,
        }
        return results

    @property
    def assumptions(self):
        return [(parse_term(a), True) for a in self.associations]

    def create_initial_objects(self):
        for o in self.initial_objects:
            self.add_object(o)

    def ground(self, o):
        self.log(f"\t\tGrounding {self.next_id} {o}")
        start = time.time()
        self.ctl.ground([("domain", [Number(self.next_id), Function(o, [])])])
        self.times["ground"] += time.time() - start
        if self.next_id > 0:
            self.ctl.release_external(Function("active", [Number(self.next_id - 1)]))
        self.ctl.assign_external(Function("active", [Number(self.next_id)]), True)

    def add_object(self, o):
        obj_atom = f"ooasp_isa({o},{self.next_id})"
        self.log(green(f"\t\tAdding object  {obj_atom}"))
        self.ctl.add("domain", [str(self.next_id), "object"], f"user({obj_atom}).")
        self.objects[o] += 1
        self.ground(o)
        self.next_id += 1
        self.cautious = None
        self.brave = None

    def add_association(self, association):
        assoc_atom = (
            f"ooasp_associated({association[0]},{association[1]},{association[2]})"
        )
        self.log(green(f"\t\tAdding association  {assoc_atom}"))
        self.associations.append(assoc_atom)
        self.cautious = None
        self.brave = None

    def get_cautious(self):
        if self.cautious:
            return self.cautious
        start = time.time()
        self.ctl.assign_external(Function("check_potential_cv"), False)
        self.ctl.assign_external(Function("computing_cautious"), True)
        self.ctl.configuration.solve.models = "0"
        self.ctl.configuration.solve.enum_mode = "cautious"
        with self.ctl.solve(yield_=True, assumptions=self.assumptions) as hdn:
            for model in hdn:
                self.cautious = model.symbols(shown=True)
            if self.cautious is None:
                self.log("\tUNSAT cautious!")
        self.ctl.assign_external(Function("check_potential_cv"), True)
        self.ctl.assign_external(Function("computing_cautious"), False)
        self.ctl.configuration.solve.models = "1"
        self.ctl.configuration.solve.enum_mode = "auto"
        self.ctl.configuration.solve.project = "auto"
        self.times["smart_generation"]["cautious"] += time.time() - start
        return self.cautious

    def get_brave(self):
        if self.brave:
            return self.brave
        start = time.time()
        self.ctl.assign_external(Function("check_potential_cv"), False)
        self.ctl.assign_external(Function("computing_brave"), True)
        self.ctl.configuration.solve.models = "0"
        self.ctl.configuration.solve.enum_mode = "brave"
        with self.ctl.solve(yield_=True, assumptions=self.assumptions) as hdn:
            for model in hdn:
                self.brave = model.symbols(shown=True)
            if self.brave is None:
                self.log("\tUNSAT brave!")
        self.ctl.assign_external(Function("check_potential_cv"), True)
        self.ctl.assign_external(Function("computing_brave"), False)
        self.ctl.configuration.solve.models = "1"
        self.ctl.configuration.solve.enum_mode = "auto"
        self.ctl.configuration.solve.project = "auto"
        self.times["smart_generation"]["brave"] += time.time() - start
        return self.brave

    def save_png(self, directory: str = "./out"):
        """
        Saves the configuration as a png using clingraph
        """
        config = "\n".join([str(c) + "." for c in self.model])
        ctl = Control(["--warn=none"])
        fbs = []
        path = settings.encodings_path.joinpath("viz_config.lp")
        ctl.load(str(path))
        path = settings.encodings_path.joinpath("ooasp_aux_kb.lp")
        ctl.load(str(path))
        ctl.load("examples/racks/kb.lp")

        ctl.add("base", [], config)
        ctl.ground([("base", [])], ClingraphContext())
        ctl.solve(
            on_model=lambda m: fbs.append(
                Factbase.from_model(m, default_graph="config")
            )
        )
        graphs = compute_graphs(fbs[0])
        render(
            graphs, format="png", name_format="config", directory=directory, view=True
        )

    def object_needed(self, s: Symbol, added_key, added: int):
        o_id, assoc, needed, c, opt, _ = s.arguments

        # Set object/association key
        if added_key is None:
            self.log("\t  ---> Apply ", s)
            added_key = (o_id, assoc)

        # Continue if different object/association key
        if added_key != (o_id, assoc):
            return added_key, added

        # Add still needed objects
        for _ in range(added, needed.number):
            if str(opt) == "1":
                a = (str(assoc), o_id, self.next_id)
            else:
                a = (str(assoc), self.next_id, o_id)
            self.add_object(c.name)
            self.add_association(a)
            added += 1
        return added_key, added

    def global_ub(self, s: Symbol):
        self.log("\t  ---> Apply ", s)
        c, needed, _ = s.arguments
        for _ in range(0, needed.number):
            self.add_object(c.name)

    def global_lb(self, s: Symbol):
        self.log("\t  ---> Apply ", s)
        c, needed, _ = s.arguments
        for _ in range(0, needed.number):
            self.add_object(c.name)

    def association_needed(self, s: Symbol):
        self.log("\t  ---> Apply ", s)
        assoc, id1, id2, _ = s.arguments
        a = (str(assoc), id1, id2)
        self.add_association(a)

    def run_function(self, f):
        self.log(f"\t+++++ {f}")

        if f == "object_needed":
            added_key = None
            added = 0

        consequences = getattr(self, f"get_{SMART_FUNCTIONS[f]["type"]}")()
        for s in consequences:
            if s.match(f, SMART_FUNCTIONS[f]["arity"]):
                if f == "object_needed":
                    added_key, added = getattr(self, f)(s, added_key, added)
                else:
                    getattr(self, f)(s)
                    return True
        if f == "object_needed":
            return added > 0
        return False

    def smart_generation(self):
        self.log(subtitle("Smart generation"))
        initial_size = self.next_id
        initial_associations = len(self.associations)
        for f in self.smart_generation_functions:
            start = time.time()
            done = self.run_function(f)
            self.times["smart_generation"]["functions"][f] += time.time() - start
            if done:
                self.log(
                    f"Smart generation: added {self.next_id - initial_size} objects and {len(self.associations) - initial_associations} associations"
                )
                return True
        return False

    def run(self):
        run_start = time.time()
        self.create_initial_objects()
        self.times["initialization"] = time.time() - run_start
        done = False

        def on_model(m):
            self.model = [str(s) + "." for s in m.symbols(atoms=True)]

        while not done:
            self.log("\n" + title(f"Next round: {self.next_id - 1} objects"))
            start = time.time()
            things_done = self.smart_generation()
            self.times["smart_generation"]["time"] += time.time() - start
            if things_done:
                continue
            self.log(subtitle(f"Solving for size {self.next_id - 1}...", "RED"))
            self.ctl.configuration.solve.models = "1"
            start = time.time()
            res = self.ctl.solve(on_model=on_model, assumptions=self.assumptions)
            self.times["solve"] += time.time() - start
            if res.satisfiable:
                done = True
                continue
            self.log(red("No solution found"))
            self.add_object("object")

        self.times["runtime"] = time.time() - run_start

        self.log(pretty_dict(self.stats))
        # print(json.dumps(self.stats, indent=4))
        if self.options.view:
            self.save_png()


# ========================== Main

if __name__ == "__main__":
    cmd_args = get_parser().parse_args()

    initial = []
    for cls in CLASSES:
        initial += [cls] * getattr(cmd_args, cls)

    if cmd_args.smart_generation is not None:
        smart_functions = [f.strip() for f in cmd_args.smart_generation.split(",")]
    else:
        smart_functions = []

    solver = OOASPRacksSolver(
        cmd_args,
        initial_objects=initial,
        smart_generation_functions=smart_functions,
    )
    solver.run()
